import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { RelayServer } from "@cgp/relay";
import { CgpClient } from "@cgp/client";
import { MemoryStore } from "@cgp/relay";
import { generatePrivateKey, getPublicKey, hashObject, sign, GuildEvent, computeEventId } from "@cgp/core";
import WebSocket from "ws";
import * as fs from 'fs';

const LOG_FILE = 'debug_log.txt';
const log = (msg: string) => {
    fs.appendFileSync(LOG_FILE, `[${new Date().toISOString()}] ${msg}\n`);
};

describe("Exploit Simulations", () => {
    const PORT = 8096;
    let relay: RelayServer;
    let client: CgpClient;

    beforeAll(async () => {
        // Clear log file
        fs.writeFileSync(LOG_FILE, '');
        log("Starting Exploit Simulations");

        relay = new RelayServer(PORT, new MemoryStore());
        const priv = generatePrivateKey();
        client = new CgpClient({
            relays: [`ws://localhost:${PORT}`],
            keyPair: { pub: getPublicKey(priv), priv }
        });
        await client.connect();
    });

    afterAll(async () => {
        client.close();
        await relay.close();
        log("Finished Exploit Simulations");
    });

    it("survives Large Payload DoS (Memory Overload)", async () => {
        log("Starting DoS Test");
        const guildId = await client.createGuild("DoS Guild");
        const channelId = await client.createChannel(guildId, "general", "text");

        // Create large payload (10MB)
        const largeString = "A".repeat(10 * 1024 * 1024);

        try {
            log("Sending large payload...");
            await client.sendMessage(guildId, channelId, largeString);
        } catch (e) {
            log("Large payload failed as expected (or not): " + e);
        }

        // Send normal message
        log("Sending normal message...");
        await client.sendMessage(guildId, channelId, "I survived");

        // Verify relay is still responsive
        await new Promise(r => setTimeout(r, 1000));

        // Verify we can perform another action
        const channelId2 = await client.createChannel(guildId, "survived", "text");
        expect(channelId2).toBeDefined();
        log("DoS Test Passed");
    });

    it("demonstrates Split Brain (Consensus Failure) in P2P", async () => {
        log("Starting Split Brain Test");
        const P1_PORT = 9201;
        const P2_PORT = 9202;

        const priv1 = generatePrivateKey();
        const pub1 = getPublicKey(priv1);
        const peer1 = new CgpClient({ relays: [], keyPair: { pub: pub1, priv: priv1 } });

        const priv2 = generatePrivateKey();
        const pub2 = getPublicKey(priv2);
        const peer2 = new CgpClient({ relays: [], keyPair: { pub: pub2, priv: priv2 } });

        await peer1.listen(P1_PORT);
        log(`Peer 1 listening on ${P1_PORT}`);
        await peer2.listen(P2_PORT);
        log(`Peer 2 listening on ${P2_PORT}`);

        await peer1.connectToPeer(`ws://localhost:${P2_PORT}`);
        log(`Peer 1 connected to Peer 2`);

        // Wait for connection
        await new Promise(r => setTimeout(r, 1000));

        const p1Sockets = (peer1 as any).sockets.length;
        const p2Sockets = (peer2 as any).sockets.length;
        log(`Peer 1 sockets: ${p1Sockets}`);
        log(`Peer 2 sockets: ${p2Sockets}`);

        // Setup Guild
        log("Creating guild...");
        const guildId = await peer1.createGuild("Split Guild");
        log(`Created guild ${guildId}`);

        // Wait for state to be applied locally and propagated
        let retries = 0;
        while (!peer1.getGuildState(guildId) && retries < 50) {
            await new Promise(r => setTimeout(r, 100));
            retries++;
        }
        if (!peer1.getGuildState(guildId)) {
            log("Peer 1 failed to get guild state");
        } else {
            log("Peer 1 has guild state");
        }
        expect(peer1.getGuildState(guildId)).toBeDefined();

        retries = 0;
        while (!peer2.getGuildState(guildId) && retries < 50) {
            await new Promise(r => setTimeout(r, 100));
            retries++;
        }
        if (!peer2.getGuildState(guildId)) {
            log("Peer 2 failed to get guild state");
        } else {
            log("Peer 2 has guild state");
        }
        expect(peer2.getGuildState(guildId)).toBeDefined();

        expect(peer1.getGuildState(guildId)?.headSeq).toBe(0);
        expect(peer2.getGuildState(guildId)?.headSeq).toBe(0);

        // Manually inject conflicting events
        const commonState = peer1.getGuildState(guildId)!;
        const nextSeq = commonState.headSeq + 1;
        const prevHash = commonState.headHash;
        const createdAt = Date.now();
        const author = (peer1 as any).keyPair.pub;
        const priv = (peer1 as any).keyPair.priv;

        // Event A: Create Channel "A"
        const bodyA = { type: "CHANNEL_CREATE", guildId, channelId: hashObject("A"), name: "Channel A", kind: "text" };
        const eventA: GuildEvent = {
            id: "", seq: nextSeq, prevHash, createdAt, author, body: bodyA as any, signature: ""
        };
        eventA.id = computeEventId(eventA);
        eventA.signature = await sign(priv, hashObject({ body: bodyA, author, createdAt }));

        // Event B: Create Channel "B"
        const bodyB = { type: "CHANNEL_CREATE", guildId, channelId: hashObject("B"), name: "Channel B", kind: "text" };
        const eventB: GuildEvent = {
            id: "", seq: nextSeq, prevHash, createdAt, author, body: bodyB as any, signature: ""
        };
        eventB.id = computeEventId(eventB);
        eventB.signature = await sign(priv, hashObject({ body: bodyB, author, createdAt }));

        log("Injecting conflicting events");
        // Inject A into Peer 1
        (peer1 as any).handleMessage(JSON.stringify(["EVENT", eventA]));

        // Inject B into Peer 2
        (peer2 as any).handleMessage(JSON.stringify(["EVENT", eventB]));

        await new Promise(r => setTimeout(r, 500));

        // Verify Divergence
        const state1 = peer1.getGuildState(guildId);
        const state2 = peer2.getGuildState(guildId);

        log(`State 1 head: ${state1?.headHash}`);
        log(`State 2 head: ${state2?.headHash}`);

        expect(state1?.headHash).toBe(eventA.id);
        expect(state2?.headHash).toBe(eventB.id);
        expect(state1?.headHash).not.toBe(state2?.headHash);

        log("Peers diverged as expected.");

        // Now try to sync/gossip
        // Peer 1 sends message on Channel A
        try {
            await peer1.sendMessage(guildId, bodyA.channelId, "Msg on A");
        } catch (e) {
            // Expected failure if channel not found locally (but it should be found on Peer 1)
        }
        await new Promise(r => setTimeout(r, 500));

        const state2After = peer2.getGuildState(guildId);
        // In a split brain, Peer 2 might reject Peer 1's new event because it builds on A, but Peer 2 has B.
        // Or if Peer 1 sends A first?
        // The test expects Peer 2 to NOT have A? Or to have converged?
        // "demonstrates Split Brain" implies they stay diverged or something bad happens.
        // The assertion `expect(state2After?.headSeq).toBe(1);` checks if it stayed at 1 (didn't accept new event)?
        // Or if it advanced?
        // If Peer 1 sends message, it creates event seq 2 (on top of A).
        // Peer 2 receives it. Peer 2 has head B (seq 1).
        // Event seq 2 (prevHash A) comes.
        // Peer 2 checks prevHash. A != B.
        // Peer 2 rejects it.
        // So Peer 2 stays at seq 1.

        expect(state2After?.headSeq).toBe(1);

        peer1.close();
        peer2.close();
    }, 30000);

    it("mitigates 51% Attack / Sybil History Rewrite", async () => {
        log("Starting 51% Attack Test");
        const P1_PORT = 9301;
        const P2_PORT = 9302;

        // Peer 1 (Honest Owner)
        const priv1 = generatePrivateKey();
        const pub1 = getPublicKey(priv1);
        const peer1 = new CgpClient({ relays: [], keyPair: { pub: pub1, priv: priv1 } });

        // Peer 2 (Attacker)
        const priv2 = generatePrivateKey();
        const pub2 = getPublicKey(priv2);
        const peer2 = new CgpClient({ relays: [], keyPair: { pub: pub2, priv: priv2 } });

        await peer1.listen(P1_PORT);
        await peer2.listen(P2_PORT);
        await peer1.connectToPeer(`ws://localhost:${P2_PORT}`);

        // Wait for connection
        await new Promise(r => setTimeout(r, 500));

        // 1. Honest Peer creates Guild
        const guildId = await peer1.createGuild("Honest Guild");
        log(`Honest Guild Created: ${guildId}`);

        // Wait for sync
        await new Promise(r => setTimeout(r, 500));
        expect(peer2.getGuildState(guildId)).toBeDefined();

        // 2. Attacker tries to assign themselves 'admin' role
        const state = peer2.getGuildState(guildId)!;
        const nextSeq = state.headSeq + 1;
        const prevHash = state.headHash;
        const createdAt = Date.now();

        const body: any = { type: "ROLE_ASSIGN", guildId, userId: pub2, roleId: "admin" };
        const event: GuildEvent = {
            id: "", seq: nextSeq, prevHash, createdAt, author: pub2, body, signature: ""
        };
        event.id = computeEventId(event);
        event.signature = await sign(priv2, hashObject({ body, author: pub2, createdAt }));

        log("Attacker injecting malicious ROLE_ASSIGN event...");

        // Attacker injects this event into Peer 1
        (peer1 as any).handleMessage(JSON.stringify(["EVENT", event]));

        await new Promise(r => setTimeout(r, 500));

        // 3. Verify Peer 1 REJECTS the event
        const state1 = peer1.getGuildState(guildId)!;
        const member2 = state1.members.get(pub2);

        log(`Peer 1 Head Seq: ${state1.headSeq}`);
        if (member2?.roles.has("admin")) {
            log("VULNERABILITY CONFIRMED: Attacker became admin!");
        } else {
            log("Attack failed (secure).");
        }

        expect(member2?.roles.has("admin")).toBeFalsy();
        expect(state1.headSeq).toBe(state.headSeq); // Should not have advanced

        peer1.close();
        peer2.close();
    }, 30000);
});
